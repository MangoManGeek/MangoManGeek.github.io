<!DOCTYPE html>
<html>
<head>
	<title>Leetcode Notes</title>
	<style type="text/css">
		body{
			font-size: 130%;
		}
		li{
  			margin: 15px 0;
		}
	</style>
</head>
<body>
<h1>Leetcode Notes</h1>
<div>
	<h3>Binary Search Tree</h3>
	<ul>
		<li>When solving BST related questions, keep in mind that <b>The range of the value of a particular node is bounded by [lower, upper]</b> depends on the tree's previous structure. <b>YOU CANNOT SIMPLY ASSUME if node.val > root.val { append node to the right}</b>. It may has to be appended to the parent's right side</li>

		<li>Interative Inorder Traversal <a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">[Leetcode 94]</a></li>

		<li>Morris Inorder Traversal -- O(n) time and <b>O(1) space</b> 
		<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/">[Leetcode 94]</a>
		<a href="https://leetcode.com/problems/recover-binary-search-tree/">[Leetcode 99]</a>
		<a href="https://www.youtube.com/watch?v=wGXB9OWhPTg">[YouTube Explanation]</a>
		<a href="https://www.geeksforgeeks.org/inorder-tree-traversal-without-recursion-and-without-stack/">[Geeks for Geeks]</a></li>
		
	</ul>
	<h3>Array</h3>
	<ul>
		<li>Sort an alomost sorted array (two elements are swaped) <b>Be Careful When Two Adjacent Element Are Swaped</b><a href="https://leetcode.com/problems/recover-binary-search-tree/">[Leetcode 99]</a></li>

		<li>Count Numbers Smaller Than the Current Number / Count of Smaller Numbers After Self :	<b>An O(n) way to achieve this is to use bucket sort, if array elements are integers. bucket[i] = count of i. Then number of elements smaller than number i is sum(bucket[:i]) <br>
		<span style="color: red">condition: range of array element must be bounded by [lower, higher] which we can use as size of bucket</span></b>
		<a href="https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/">[Leetcode 1365]</a></li>
	</ul>
</div>
</body>
</html>